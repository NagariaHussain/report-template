\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[12pt,]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={End Term Project Report: otoDecks},
            pdfauthor={Mohammad Hussain Nagaria},
            colorlinks=true,
            linkcolor=blue,
            filecolor=Maroon,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=2.5cm,a4paper]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{fancyvrb,newverbs}

\definecolor{bgcolor}{HTML}{DADADA}
\let\oldtexttt\texttt

\renewcommand{\texttt}[1]{
  \colorbox{bgcolor}{\oldtexttt{#1}}
}

\hypersetup{
    bookmarksopen=true,
    linkcolor=blue,
    urlcolor=NavyBlue,
    filecolor=magenta,
}

\title{End Term Project Report: otoDecks}
\author{Mohammad Hussain Nagaria}
\date{5 March, 2021}

\begin{document}
\maketitle

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{3}
\tableofcontents
}
\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

As I was coding along with the lectures and completing the worksheets,
by the end of the course, I already had the
\protect\hyperlink{r1-basic-functionality}{basic functionality} in
place.

I planned to start with the
\protect\hyperlink{r3-the-music-library}{playlist component}, since I
found it interesting and also very essential for such an application.
Once, I was done with the playlist component, I moved to give the GUI an
\protect\hyperlink{r4-the-new-gui-layout}{overhaul}. At the very last, I
worked on the \protect\hyperlink{r2-the-custom-deck-control}{custom deck
control} and added some finishing touches. I have used a variety of
different things available in the \textbf{JUCE Library} and used the
JUCE \emph{documentation}\footnote{https://TODO.com} for learning about
different classes and methods available on those classes.

Detailed information on the achievements of different requirements makes
the rest of this report. I have attached \textbf{screenshots} and
\textbf{code snippets} at various places to make things clearer.

\hypertarget{requirements}{%
\section{Requirements}\label{requirements}}

\hypertarget{r1-basic-functionality}{%
\subsection{R1: Basic Functionality}\label{r1-basic-functionality}}

This application contains all the basic functionality shown in the
course lectures (I have been coding along, :)):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The user can load audio files into any of the two Decks. This can
  either be done by \textbf{clicking the load button} in the Deck or by
  \textbf{dragging and dropping} a music file onto the deck component.
  (\textbf{R1A})
\item
  Music files can be loaded and played simultaneously in the two decks.
  (\textbf{R1B})
\item
  The volumes of each of the tracks can be controlled independently,
  using the volume slider in the deck. (\textbf{R1C})
\item
  The speeds of each of the tracks playing the two decks can also be
  controlled independently, using the speed slider in the deck.
  (\textbf{R1D})
\end{enumerate}

In the lectures, we are shown how to change the play head using a
slider. I went one step ahead to change this behavior into something
much \textbf{more natural}. I have used some mouse click listeners and
some geometry to enable the user to \textbf{drag the play head
rectangle} to change the play head position. This seemed a bit tricky to
implement at first, but gave a lot of satisfaction once it was done. The
screenshot below shows a user dragging the playhead indicator to a new
position (\textbf{Extra}):

{Screenshot of play head being dragged to a new position}

\hypertarget{r2-the-custom-deck-control}{%
\subsection{R2: The Custom Deck
Control}\label{r2-the-custom-deck-control}}

\hypertarget{r3-the-music-library}{%
\subsection{R3: The Music Library}\label{r3-the-music-library}}

The Music Library Component has been \emph{encapsulated} into a
component called: \texttt{MusicLibrary}. It takes 3 constructor
arguments: pointers to the 2 \texttt{DJAudioPlayer}s and pointer to the
\texttt{DeckPanel} component. This component is \textbf{resizable}, so
the user can drag along the top edge to change its height. The resizing
was made possible using the \texttt{ResizableBorderComponent} inside the
\texttt{DeckPanel} and some bounds setting in the \texttt{resized()}
method of the main component:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{deckPanel.setBounds(}
\NormalTok{    deckPanel.getX(), }
\NormalTok{    deckPanel.getY(), }
\NormalTok{    getWidth(), }
\NormalTok{    deckPanel.getHeight()}
\NormalTok{);}

\NormalTok{musicPanel.setBounds(}
    \DecValTok{0}\NormalTok{, }
\NormalTok{    deckPanel.getHeight(), }
\NormalTok{    getWidth(), }
\NormalTok{    getHeight() - deckPanel.getHeight()}
\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{musicPanel} is the name of the instance of MusicLibrary created
in the MainComponent Class.

The first problem at hand was to add some persistent storage. While
browsing through the JUCE documentation, I came across
\texttt{juce::PropertiesFile} class. This class can be used to maintain
a file for application data. The music library creates a pointer to a
\texttt{PropertiesFile} and sets it up in the constructor via a method
called \texttt{loadPlaylist}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ MusicLibrary::loadPlaylist() \{}

    \CommentTok{// Configure options for properties file}
\NormalTok{    juce::PropertiesFile::Options playlistFileOptions;}
\NormalTok{    playlistFileOptions.applicationName = }\StringTok{"music"}\NormalTok{;}
\NormalTok{    playlistFileOptions.filenameSuffix = }\StringTok{".playlist"}\NormalTok{;}
\NormalTok{    playlistFileOptions.folderName = }\StringTok{"userMusicData"}\NormalTok{;}
    \CommentTok{// ... other configuration omitted here}

    \CommentTok{// Create Property File object}
\NormalTok{    playlistFile = }\KeywordTok{new}\NormalTok{ juce::PropertiesFile(playlistFileOptions);}

    \CommentTok{// Load playlist}
    \DataTypeTok{int}\NormalTok{ numSongs = playlistFile->getAllProperties().size();}

    \CommentTok{// Resize the vector to required size}
\NormalTok{    songs.resize(numSongs, juce::String());}

    \CommentTok{// Get all StringPairs from properties file}
\NormalTok{    juce::StringPairArray songArray = playlistFile->getAllProperties();}

    \CommentTok{// Fill the vector with song file paths}
    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

I have \textbf{used this file to store paths to song/track} files. The
content of the file is \emph{loaded into the memory} (in a vector of
\texttt{juce::String}s called \texttt{songs}, which is a private member
of the MusicLibrary class) at the end of the method given above. Hence,
whenever the application is started, previously \emph{saved playlist} is
loaded into the memory and displayed via the \texttt{TableListBox}
component. (\textbf{R3E})

\hypertarget{load-and-search}{%
\subsubsection{Load and Search}\label{load-and-search}}

Other than a \texttt{TableListBox} component, the \texttt{MusicLibrary}
component also has two other important components described below:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{The load button}: This is a TextButton which when clicked
  prompts the user to select a file. Upon selection the file will be
  \emph{appended to the end of the playlist} and the properties file
  (containing the playlist data) will also be \textbf{re-written with
  new playlist state} (\textbf{R3A}). The updating of the playlist file
  happens in a method called \texttt{MusicLibrary::updatePlaylistFile}
  which carries out the following main operations:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{// Clears the playlist file}
\NormalTok{playlistFile->clear();}


\CommentTok{// Inserts new data into playlist file}
\ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{size_t}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i < songs.size(); ++i)}
\NormalTok{\{}
\NormalTok{    playlistFile->setValue(juce::String(i), songs[i]);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This method is called whenever there is change the \texttt{songs} vector
in the memory to update the file on disk.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{A search box} (TextEditor): The user can start typing a track
  name in this box and the playlist will immediately updated to
  \textbf{show only the songs that contain the search query} (whatever
  the user has typed in the box). The main logic of this component is
  encapsulated in a method called \texttt{startSearch} which takes in
  the query string and filters the songs list (\textbf{R3C}):
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]

\ControlFlowTok{for}\NormalTok{ (}\AttributeTok{const} \KeywordTok{auto}\NormalTok{& song : songs)}
\NormalTok{\{}
    \ControlFlowTok{if}\NormalTok{ (song.containsIgnoreCase(searchString)) }
\NormalTok{    \{}
\NormalTok{        filteredSongs.push_back(song);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When the user types something in the box, the music library component
\emph{goes into search mode}, i.e.~the boolean variable
\texttt{showingSearchResults} is set to \texttt{true}.

\hypertarget{the-pop-up-menu}{%
\subsubsection{The Pop Up Menu}\label{the-pop-up-menu}}

A very common pattern I have observed in many GUI softwares is that,
whenever there is a list of things, the user can right click on a single
row of the list and a \emph{contextual menu pops up} (pop up menu). The
menu provides the user with some actions that can be performed for that
particular row.

I have implemented the same thing in the music library component using
\texttt{juce::PopupMenu} class and by overriding \texttt{cellClicked}.
The screenshot below shows the pop up menu:

{ScreenShot of the Pop Up menu}

Here is a detailed description of what happens when a particular option
is selected from the pop up menu:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Load in Player 1}: It is very clear from the text what will
  happen if this option is selected: this particular track will be
  loaded in Player 1 (or Deck 1).
\item
  \textbf{Load in Player 2}: Selecting this option loads the track in
  player 2. (\textbf{R3D})
\item
  \textbf{Move Up}: The playlist I maintain in memory (and also the file
  on the disk) is \textbf{ordered}. The user can easily keep her/his
  tracks in order. If this option is selected, that specific track is
  moved up in the playlist. The logic behind this is simple: two
  elements of the \texttt{songs} vector get swapped:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Swap current row with row above (if any)}
\ControlFlowTok{if}\NormalTok{ (rowNumber >= }\DecValTok{1}\NormalTok{)}
\NormalTok{\{}
\NormalTok{    juce::String temp = songs[rowNumber];}
\NormalTok{    songs[rowNumber] = songs[rowNumber - }\DecValTok{1}\NormalTok{];}
\NormalTok{    songs[rowNumber - }\DecValTok{1}\NormalTok{] = temp;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\item
  \textbf{Move Down}: This does the exact opposite of the \textbf{Move
  Up} option: \textbf{moves the track down one position} (if it is not
  the bottom most).
\item
  \textbf{Remove}: Removes the track from the playlist.
\end{enumerate}

The method \texttt{updatePlaylistState()} is called to update the state
of the music library. This method \textbf{updates the
\texttt{TableListBox} component}, \textbf{calls \texttt{repaint()}}
function and also \textbf{calls the \texttt{updatePlaylistFile()}
method} discussed above.

I have created an \texttt{enum} called \texttt{PopUpOption} to relate
the above options to integers which are used in the \texttt{cellClicked}
method to detect which one of the options was clicked and then perform
the action associated with that option:

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{// MusicLibrary.h}

\KeywordTok{enum}\NormalTok{ PopUpOption}
\NormalTok{\{}
\NormalTok{    LOAD_IN_1 = }\DecValTok{1}\NormalTok{,}
    \CommentTok{// ....}
\NormalTok{    REMOVE = }\DecValTok{4}
\NormalTok{\};}

\CommentTok{// MusicLibrary.cpp}

\DataTypeTok{void}\NormalTok{ MusicLibrary::cellClicked(...)}
\NormalTok{\{}
    \CommentTok{// ...}
    \CommentTok{// If right clicked}
    \CommentTok{// show the pop up menu and capture the result}
\NormalTok{    result = playlistControlMenu->show();}

    \CommentTok{// Perform action based on result}
    \ControlFlowTok{if}\NormalTok{ (result == PopUpOption::LOAD_IN_1)}
\NormalTok{    \{}
        \CommentTok{// ...}
\NormalTok{    \}}

    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The data for the table list box is drawn using a method called
\texttt{drawCellFor()}. The \textbf{data is extracted from the
\texttt{songs} vector} and drawn as text using the drawing context
\textbf{\texttt{g}}. The name of the song is found in a method called
\texttt{getSongName()} and a string representing the song length (in the
format MM:SS) is calculated in the \texttt{getLengthString()} method.
(\textbf{R3B})

\hypertarget{r4-the-new-gui-layout}{%
\subsection{R4: The New GUI Layout}\label{r4-the-new-gui-layout}}

I have tried to give the User Interface a complete overhaul using
different \textbf{colors}, a \textbf{new layout} and also
\textbf{resizable panels}.

A \emph{difference between the old and the new GUI} can easily be
observed by seeing the screenshots below:

{Screenshot of Old GUI}

{Screenshot of the New GUI}

Two \texttt{juce::LookAndFeel\_V4} objects are used to \textbf{apply
color theme} to the GUI. One is created and applied to the
\texttt{MainComponent} itself and other one (called
\texttt{playlistComponentTheme}) in the \texttt{MusicLibrary} component.
Both the objects are private to thier respective component classes.

There are private methods called \texttt{setCustomTheme} in both the
above mentioned components to apply colors to different types of
component parts. The \texttt{setColour()} method is called on the
\texttt{LookAndFeel\_V4} object to set colors for different UI
specifications. The below code snippet shows the setting of some
colours: (\textbf{R4A})

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// MainComponent.h}
\KeywordTok{private}\NormalTok{:}
    \CommentTok{// ...}
\NormalTok{    juce::LookAndFeel_V4 themeData;}
    \CommentTok{// ...}

\CommentTok{// MainComponent.cpp}
\DataTypeTok{void}\NormalTok{ MainComponent::setCustomTheme()}
\NormalTok{\{}
    \CommentTok{// primaryColor = juce::Colours::rebeccapurple}
\NormalTok{    themeData.setColour(juce::Slider::thumbColourId, primaryColor);}
\NormalTok{    themeData.setColour(}
\NormalTok{        juce::Slider::ColourIds::textBoxTextColourId, }
\NormalTok{        juce::Colours::white}
\NormalTok{    );}
    \CommentTok{// ...}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-resizable-panels}{%
\subsubsection{The Resizable Panels}\label{the-resizable-panels}}

Now, coming to the resizable part. We can observe in many software GUIs
that the user is \textbf{able to resize a particular window by dragging
at an edge}. This pattern is very common in the Adobe Suite of products
(and many other professional software packages). Therefore, I had it in
the back of my mind since the beginning. To do that, I had to
\emph{abstract out the two \texttt{DeckGUI}s into a single component}
(called \texttt{DeckPanel} here).

The code that lets us achieve this resizable window uses the
\texttt{juce::ResizableBorderComponent} from the JUCE class
library\footnote{https://TODO.com}.

A pointer to the above class's object is created in \texttt{DeckPanel.h}
and also a pointer to a \texttt{juce::Component} object is created to
hold a pointer to the parent component (which is passed as a constructor
argument from the parent, in this case, it is the
\texttt{MainComponent}).

The below code does the magic:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// DeckPanel.h}

\NormalTok{juce::ResizableBorderComponent* border;}
\CommentTok{// DeckPanel.cpp}
\NormalTok{DeckPanel::DeckPanel(...) \{}
\NormalTok{    addChildComponent(border = }\KeywordTok{new}\NormalTok{ juce::ResizableBorderComponent(}
        \KeywordTok{this}\NormalTok{,}
        \KeywordTok{nullptr}
\NormalTok{    ));}
\NormalTok{\}}

\CommentTok{// Set the thickness of the border}
\CommentTok{// 10 on top egde, 0 on the other edges}
\NormalTok{border->setBorderThickness(juce::BorderSize<}\DataTypeTok{int}\NormalTok{>(}\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{));}
\NormalTok{border->setBounds(}\KeywordTok{this}\NormalTok{->getBounds());}

\CommentTok{// Make the border visible and draggable}
\NormalTok{border->setVisible(}\KeywordTok{true}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

The \texttt{juce::ResizableBorderComponent} \textbf{automagically (yes!)
calls the resize method of its parent component whenever the user drags
the border}. The border object gets \texttt{delete}d in the destructor.

\hypertarget{conclusion}{%
\section{Conclusion}\label{conclusion}}

Overall this project was the best project I have got till now in this
degree. It required a lot of \textbf{problem solving} and planning to
get it done. Still there are a lot of areas for improvement. Some of the
things that could be added/made better are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The ability to save the mixed track on the disk.
\item
  The ability to cut and join tracks.
\item
  The app could use some \emph{animations} to make it more fun to use.
\item
  More controls and filters!
\end{enumerate}

\hypertarget{references}{%
\subsection{References}\label{references}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  JUCE Class Reference:
\item
  JUCE Tutorials:
\end{enumerate}

\hypertarget{links}{%
\subsection{Links}\label{links}}

\begin{itemize}
\tightlist
\item
  Tutorial Video:
\end{itemize}

\end{document}
